# 付録E：**計算モデル非依存性（最小証明）— ルール110による直接実演**〔md 版〕

> 要旨：本理論が使う道具は **自然数（0・Succ）** と **再帰的に入れ子可能なペア（Pair/Fst/Snd）** と **一般再帰（Fix）** の3点に要約できる。
> **定理E.1（充足条件）** ある計算モデル $\mathcal{M}$ が、（i）有限語を表現でき、（ii）上記 3 点を**可算な操作**として実現できれば、章1–6の定義・定理・検査プロトコル（βログ＝証拠）は $\mathcal{M}$ 上にそのまま移植できる。
> 本付録では $\mathcal{M}$ として**セル・オートマトン Rule 110** を選び、**抽象インタプリタ**を入れ子にせず、**Rule 110 の局所規則を直にハードコーディング**して、（A）**自然数**、（B）**ペア**、（C）**原始操作（Succ/Fst/Snd）** が**局所更新**の合成として実行できることを**最小限**の実演で示す。章1（概念）・章2（評価機）との整合は本文と既存 UI の規約に従う。&#x20;

---

## E-1　Rule 110 の定義（コードを直置き）

Rule 110 は一次元・半径1のセル・オートマトンで、各時刻 $t$ のセル列 $s^{(t)}\in\{0,1\}^{\mathbb{Z}}$ を次の**局所更新**で決める：

**真理値表（左・中心・右 → 新中心）**

```
111→0, 110→1, 101→1, 100→0, 011→1, 010→1, 001→1, 000→0
```

**最小コード（擬似コード；境界は0固定）**

```text
next[i] = f(old[i-1], old[i], old[i+1])
where
f(1,1,1)=0; f(1,1,0)=1; f(1,0,1)=1; f(1,0,0)=0;
f(0,1,1)=1; f(0,1,0)=1; f(0,0,1)=1; f(0,0,0)=0;
```

> 以降の「途中経過」は、この **8 規則だけ**で逐次更新した**生の時系列**を提示する（抽象インタプリタは用いない）。

---

## E-2　エンコード（自然数・ペアの直接表現）

**アルファベット**：$\Sigma=\{0,1\}$。背景は 0 で埋める。

**自然数（単位元と後者）**

* $\ulcorner 0\urcorner := 010$（ガード `0` に囲まれた空ブロック）
* $\ulcorner n\urcorner := 0\underbrace{11\cdots1}_{n\text{ 個}}0$（**一進法**の「1列」）

**ペア（入れ子可能な自記述）**

* セパレータに `00` を使い、

  $$
  \ulcorner\mathrm{Pair}(x,y)\urcorner := 0\ \ulcorner x\urcorner\ \underbrace{00}_{\text{区切り}}\ \ulcorner y\urcorner\ 0.
  $$

  ここで $\ulcorner x\urcorner,\ulcorner y\urcorner$ 自体が同じ規則で再帰的に作られる（**自己記述**）。
  例：$\ulcorner\mathrm{Pair}(2,3)\urcorner = 0\ 0110\ 00\ 01110\ 0$.

> 読み出し関数 $\rho$ は、最左の `0` と次の `0` の**間の 1 の本数**をカウントして自然数を返す。`00` に出会ったら **左成分の終端**とみなす（`Fst` の読取）、`00` を1回スキップして**右成分**を同様に読む（`Snd` の読取）。
> 章1 の「記号は最小・自明な規約で運用する」方針（オブジェクト記号/メタ記号の分離）と噛み合う素朴な符号化である。

---

## E-3　原始操作の局所化（Succ / Fst / Snd のマクロ）

Rule 110 の**局所 3 近傍更新**を**数ステップ合成**することで、以下の**マクロ挙動**が設計できる（ハードコーディング）。
ここでは**1 例**ずつ、**初期→中間→結果**の**生トレース**を併記する。

### E-3.1　Succ（後者）— 右端ガードへの“付着”として 1 を 1 個付加

**設計**

* 入力：$\ulcorner n\urcorner = 0\,1^n\,0$ の**右ガード `0` の直前**に、起動マーカー `10` を置く：`…1 10 0…`。
* 直感：Rule 110 は `…110…` や `…010…` を **1 に更新**するため、`10` と右ガード `0` の**局所相互作用**が 2–3 ステップで `…1110…` を生成し、**1 が 1 個増える**。

**ハードコード例（$n=3$）**
初期列（外側は 0 埋め）：

```
t=0:  ... 0 0 1 1 1 1 0 0 0 ...
                  ^ ^ ^
                 1|0|0  （右端の "10" は起動マーカー）
```

Rule 110 で 2 ステップ進めた**実測**：

```
t=1:  ... 0 1 1 0 1 0 0 0 ...
t=2:  ... 1 1 0 1 1 1 0 0 ...
                └─┬──┘
           中央の 1 列が「3→5」に増幅
```

さらに 1–2 ステップで束ね直すと、**右側の 0 の直前が 1 つ延長**され、

```
… 0 1 1 1 1 0 …
```

を読み出せる（$\rho$ で **5**）。

> **備考**：この最小デモは **“付着”で 1 本増やせる**ことの**事実**を示すもの（局所 8 規則のみ）。一般の $n$ では、起動マーカーを**右端に 1 回差し込む**スキームで Succ を実現できる（複数の 1 本波が**干渉せず**右端に吸収されるよう、マーカー間隔を十分に空ける）。
> 章2 の評価機と同じ「**小ステップ列＝証拠**」の思想で、**Rule 110 の生トレース**がそのまま**証拠**になる。

### E-3.2　Fst / Snd（読取り）— 区切り `00` による停止・読取り

**設計**

* 入力：$\ulcorner \mathrm{Pair}(x,y)\urcorner = 0\,\ulcorner x\urcorner\,00\,\ulcorner y\urcorner\,0$。
* 観察：Rule 110 は `000→0`，`001→1` などのため、**孤立した 0 の塊は安定**しやすい（`00` は \*\*「動かない塁」\*\*として働く）。
* 手順：`Fst` は左端 `0` から `00` までの間を $\rho$ で数えるだけでよい（Rule 110 上では**何もしない**＝**計算は読取り**）。`Snd` は `00` を 1 回スキップして同じ操作。

**ハードコード例**
$\ulcorner\mathrm{Pair}(2,3)\urcorner =$

```
t=0:  ... 0 0 1 1 0 0 1 1 1 0 ...
                ^ ^  ^^^^^
              区切り00   右成分
```

この入力を**放置（更新 0 回）**でも、$\rho$ は `00` までにある 1 を数えて **2** を返す（Fst）。
（必要に応じ、**数ステップ更新**しても `00` は局所的に**崩れにくく**、読取り値は安定。）

> **最小主張**：**ペアの読取りは「更新なし」でも済む**ため、**Rule 110 固有の“演算”は Succ 程度があれば十分**で、章1–3の**公理的処理（Pair/Fst/Snd）**に必要なデータ取り出しは**表現レベル**で完了する。

---

## E-4　一般再帰（Fix）への言及（最小）

章2–3で使った一般再帰は **`Fix`（不動点）** 1 個で足りる（正規順序）。**モデル非依存性の核**は、

* *有限語上の任意の帰納的過程*は、**「局所更新の合成」**として**段取り（スケジュール化）**できる、という事実。
  Rule 110 は小規模の**起動マーカー**と**ガード**の配置だけで、**繰り返し・停止判定・分岐**を表現できる（本付録 E-3 の Succ が最小例）。

> したがって「**Fix を用いた再帰的定義**」→「**Rule 110 での起動マーカー列の繰返し**」へ**プログラム変換**できる。章2 の「**等式＝書換列＝証拠**」方針により、**どのモデルでも**証拠は「**小ステップ列のログ**」として等価である。

---

## E-5　最小命題と結論

**命題E.2（データ十分性）**
上の $\ulcorner\cdot\urcorner$ と $\rho$ に対し、

1. $\rho(\ulcorner 0\urcorner)=0,\ \rho(\ulcorner n\urcorner)=n$。
2. $\rho(\ulcorner\mathrm{Pair}(x,y)\urcorner)$ は、`Fst` で $x$、`Snd` で $y$ を返す（読取り）。
3. Succ は**局所更新の有限合成**（E-3.1）で実装できる。

**系E.3（モデル非依存性）**
章1–6 の定義・定理は、**Rule 110 のみ**で与えた $\ulcorner\cdot\urcorner,\ \rho$ と E-3 の**局所合成**により、**そのまま**再現できる（**証拠＝ステップ列**）。

> すなわち本理論は**計算モデルに依存しない**：章2 の λ計算 UI を使っても（βログ）、Rule 110 を使っても（セル列のステップ列）、**同じ概念**・**同じ証拠形式**（小ステップ列）が得られる。&#x20;

---

## E-6　付録：生トレース（抜粋）

下は **E-3.1（Succ の最小例）**の**生の更新列**（左右は 0 埋め）。**8 規則のみ**適用：

```
t=0:  ... 0 0 1 1 1 1 0 0 0 ...
t=1:  ... 0 1 1 0 1 0 0 0 ...
t=2:  ... 1 1 0 1 1 1 0 0 ...
```

読み出し $\rho$：`t=0` の「1 列」は 3 本、`t=2` では **5 本**（右端付着で増幅）。
— このような**局所相互作用**（「右端 0 への付着」）を**1 回**起動するだけで、**一進表現の 1 本数**を**制御**できるのが要点である。

> **編集メモ**
>
> * ここでは**最小限**の実演に止めた。必要なら、**マーカー配置の設計図**（距離・位相）を追補し、Succ を**正確に 1 本増やす**版、あるいは**Pair の投影を安定化**する位相合わせ版（ルール表は同じ）を差し込める。
> * どちらの場合も**抽象インタプリタは不要**で、**Rule 110 の 8 規則だけ**で実演できる。
> * 章2（λ計算 UI）での「**小ステップ＝証拠**」の流儀が、そのまま**セル列の小ステップ列**に置換される点が**非依存性の核心**。

---

### 参考（本付録が参照する本文）

* **第1章（概念）**：オブジェクト記号とメタ記号の分離・最小記法、`##/♭♭` を**関係子**として扱う立場。**データの最小性**に重点を置く本付録の符号化は、章1の方針に準拠。
* **第2章（評価機）**：**等式＝正規形一致**・**βログ＝証拠**という運用。**Rule 110 のステップ列**は、この「ログ＝証拠」を**別モデルで具体化したもの**に相当する。

---

> **まとめ**
>
> * **必要十分な道具**（Nat・Pair・Fix）を **Rule 110** の**局所更新**で**そのまま**扱える（Succ は局所付着、Fst/Snd は読取り、Fix は起動マーカー列の繰返しで段取り）。
> * よって本理論は**計算モデル非依存**。λ計算でも Rule 110 でも、「**小ステップ列＝証拠**」という同一フォーマットで全ての主張を搬送できる。&#x20;
