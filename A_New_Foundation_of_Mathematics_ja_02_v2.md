# 数学の新しい基礎づけ — 第2章：計算モデルと評価機（最小 λ計算）〔md版・本編〕

> 本章は **“計算＝証拠”** を実現するための最小計算モデル（型なし λ 計算）と、その評価機（v4→v6 系 UI）の**仕様書＋運用ガイド**である。実装の細部は巻末のコード挿入位置（**Code Slot**）にまとめて配置し、本章では**言語・評価・UI・再現性**を確定させる。章1の概念（##／♭♭＝関係子、$M=(k,a)$、$CR=(M,M)$ など）に整合する\*\*前処理（表層糖衣）\*\*もここで定義する。&#x20;

---

## 2-0　本章の目的

* **最小言語**（変数／λ抽象／適用）のみを中核に据え、\*\*評価戦略＝正規順序（左最外）\*\*を採用する。
* **βログを証拠**とする設計：1 ステップごとの書換列がそのまま証跡になる（停止すれば正規形）。
* **外部理論に過度に依存しない**。必要な再帰は言語内の \*\*固定点コンビネータ（`Fix`）\*\*で与える。
* 章1の独自記法（##／♭♭ 等）を **前処理**で λ コアへ展開して実行可能にする。&#x20;

---

## 2-1　言語仕様（最小 BNF とトークン規約）

### 2-1-1　BNF（コア言語）

```bnf
<term> ::= <var>
         | "λ" <var> "." <term>       ; λ抽象（"\" でも可）
         | "(" <term> <term> ")"      ; 適用（左結合）

<var>  ::= 先頭英字 / "_" に続く英数字 / "_"
```

**コメント**：行内の `//` 以降は無視。**複数式**は `;` 区切りで順次評価／定義。
**定義**：`name = <term>` を環境に登録（**自己参照の直接定義は禁止**）。

### 2-1-2　表層糖衣（章1との橋渡し）

章1の**関係子**をコアへ落とす**前処理**（編集段階でテキスト置換 → コア λ へ展開）：

* `a##` / `a♭♭` / `a#` / `a♭` / `a`（null） → `Rel_apply <RelCode> a`（`RelCode∈ℤ`）
  例：`##→+2`，`#→+1`，`null→0`，`♭→-1`，`♭♭→-2` …
* 仕向け先の **語彙（`Rel_apply` ほか）** は 3 章の定義群で与える（本章では**前処理規約**のみを固定）。
* `CR` や `M` といった合成オブジェクトは**構築関数**（`mkM k a`／`mkCR u v`）へ展開する設計とする。
  この“前処理→コア”の分離で、**記法は章1のまま**・**実行は章3の定義に依存**という責務分離を保つ。

> **実装注**：前処理自体はインタプリタに内蔵してもよいが、再現性の観点から**別モジュール**化して記録する。

---

## 2-2　意味論（小ステップ β簡約・正規順序）

### 2-2-1　評価戦略

* **正規順序（左最外）**：最左の外側 redex を優先。正規形が存在すれば**必ず到達**する戦略。
* **逐次ログ**：各ステップの式（α同型は表示で解消）を**時系列で記録**し、証拠とする。

### 2-2-2　推論規則（骨子）

$$
\frac{ }{(\lambda x.\,M)\;N \;\rightarrow\; M[x:=N]}\quad(\beta)
\qquad
\frac{M\rightarrow M'}{M\,N \rightarrow M'\,N}\quad(\text{App-L})
\qquad
\frac{N\rightarrow N'}{V\,N \rightarrow V\,N'}\ (\text{App-R},\ V\text{は値})
$$

$$
\frac{M\rightarrow M'}{\lambda x.\,M \rightarrow \lambda x.\,M'}\quad(\lambda)
$$

**値**は λ抽象。App-R は**正規順序**では引数評価を後回しにするが、表示上の簡約ログで必要に応じて示す。

### 2-2-3　代入・α変換・捕獲回避

* **代入** `M[x:=N]` は**捕獲回避**のため **α変換**（束縛変数のリネーム）を伴う。
* **新鮮変数生成**は衝突集合を動的に蓄積して回避（`x, x_1, x_2, …`）。
* これらは v4→v6 実装の `freeVariables / substitute / generateFreshVar` に対応。

---

## 2-3　環境・定義・展開

* **環境**：`name ↦ termAST` の辞書。`name = term` は**構文解析→AST 登録**。
* **展開（expandByEnv）**：評価前に **自由変数の定義**を AST へ**インライン展開**。
* **循環検出**：展開時に訪問集合で**直接・間接再帰の無限展開**を検出し、**エラー**にする。
  （一般再帰は **`Fix`** で項内部に作る。**環境レベルでは循環禁止**。）

---

## 2-4　固定点コンビネータ（再帰の最小実現）

* **正規順序向け**：
  `Fix ≜ λf.(λx.f (x x)) (λx.f (x x))`
  補題：`Fix F = F (Fix F)`（1 ステップ展開で示せる）。
* **将来の CBV 互換**（任意）：
  `FixV ≜ λf.(λx.f (λv.(x x) v)) (λx.f (λv.(x x) v))`
* 実装では **`Fix` を標準語彙**として用意し、gcd／多項式除算などの**一般再帰**に利用する。

---

## 2-5　UI／ログ／操作（v4→v6 系）

### 2-5-1　UI 要素と挙動

* **Evaluate (or Define)**：式の評価／定義登録。
* **Reset Definitions**：環境を初期化。
* **Stop Evaluation**：長計算をユーザ操作で中断。
* **Steps executed**：実行ステップ数。
* **表示領域**：

  * `【Input Expression】` 原式
  * `【After Environment Expansion】` 展開後 AST の pretty-print
  * `【Evaluation Steps】` 小ステップ列（**現在行ハイライト**）
  * `【Final Result】` 最終式（正規形または途中）
* **スクロール**：評価終了・定義サマリー表示後に**末尾へ自動スクロール**。

### 2-5-2　エラーと上限

* **循環参照**（展開時）・**パースエラー**・**上限到達**（既定 `100000` ステップ）を明示。
* 正規順序でも**正規形が存在しない**項は止まらないため、**上限**と**Stop**でオペレーション上の境界を与える。

---

## 2-6　標準語彙（コア・ミニマム）

本章では**語彙名と契約**のみ固定し、**定義本体は巻末 Code Slot** に配置する（章3で数学語彙を拡張）。

* **論理・組**：`True/False/If/Pair/Fst/Snd/Not/And/Or`
* **Nat**：`Zero/Succ/Add/Mul/Pow/Pred/Sub/Leq/Lt/IsZero`
* **Z**：`Zpos/Zneg/Z_zero/Z_isNeg/Z_nat/Z_neg/Z_add/Z_sub/Z_mul/Z_lt`
* **Rat**：`Rat/Rat_num/Rat_den/Rat_norm` と `rat_add/sub/mul/div`（**返り値は正規形**）
* **補助**：`Fix/Mod/GcdNat/Nat_div_exact/Z_abs_nat`
* **（前処理ターゲット）**：`Rel_apply/mkM/mkCR`（章1記法の受け口）
  これらの**契約**に基づき、章1の例はそのまま評価機で再現できる。

---

## 2-7　表層前処理（M/CR 記法の展開規約）

* `a##` 等の**関係子**は `Rel_apply (+2) a` のような**整数パラメータ**へ写す（`♭♭→-2` など）。
* `M` は `mkM k a`、`CR` は `mkCR u v`。
* 例：`1♭ + 1#` → `M_add (mkM (-1) 1) (mkM (+1) 1)` → `…` → `mkM 0 2`。
* 章3で `Rel_apply/mkM/mkCR` の**具体定義**と**比較器 `cmpM/cmpCR`** を与える。

---

## 2-8　再現性：βログ＝証拠

* **同値の証拠**＝**正規形一致**。
* **性質の証拠**＝**等式の両辺を評価**し、`Assert` で `True` に正規化すること。
* **ログ保存**：重要な導出は**βログを添付**（章末付録 A のケース表参照）。

---

## 2-9　チュートリアル（最小例）

> **注**：ここでは**短いスニペット**のみ記す。長い定義（`Rat_norm` など）は巻末 Code Slot を参照。

### (1) `Fix` の挙動（固定点恒等式）

```
Fix = λf.(λx.f (x x)) (λx.f (x x))
F   = λrec. λn. If (IsZero n) Q1 (rat_mul n (rec (Pred n)))
; Evaluate: Fix F
; βログの最終行が F (Fix F) を示す
```

**ポイント**：環境レベルの自己参照なしに、**項内部で再帰**が実現する。

### (2) 有理の正規化

```
; 1/2 + 1/2 = 1
Rat_add_norm QHalf QHalf
```

**期待**：`Q1` に正規化（分母正・既約）。

---

## 2-10　テスト・ハーネス（断片）

* `Assert : Bool→Bool` を用意し、`True` に正規化すれば合格。
* **バッチ検査**：Church リストで直積を回す薄いスイート（章末付録・拡張版あり）。
* 例：可換律 `CR_add x y = CR_add y x` を集合 $\{0,1,\tfrac12,\varepsilon,-\varepsilon,\dots\}$ 上で網羅検査。
  （詳細は付録 A／拡張スイート参照。）

---

## 2-11　エンジニアリング指針（保守・拡張）

* **安全第一**：前処理は**純粋関数**として分離、差分管理する。
* **可観測性**：ログは**最小粒度の β ステップ**で、UI は**常に末尾スクロール**。
* **拡張点**：

  * CBV 互換の `FixV`
  * 共有（グラフ還元）・メモ化
  * 書換の**健全性テスト**（1 ステップ同値）自動化
  * `M/CR` の強い正規化（ord₀-drop／モニック化／content 約分／多項式 gcd）を**オプション化**（既に v6 で導入）。

---

## 2-12　本章まとめ

* **最小 λ**＋**正規順序**＋**βログ**で「計算＝証拠」を確立。
* **前処理**で章1の記法をコアに落とし、章3の定義群へ橋渡し。
* **環境は循環禁止**、再帰は\*\*`Fix`\*\* の内部構成で行う。
* UI・ログ仕様は v4→v6 系の実装に準拠し、**再現性**のある実験プロトコルを提供する。

---

# Appendix（配置計画と Code Slot）

> 大きなコードは**巻末**に一括配置します。本文からは **相対参照**し、将来の差し替えを容易にします。

## Code Slot A — インタプリタ本体（HTML+JS, v4→v6 系）

* **想定パス**：`appendix/interpreter.html`
* **内容**：UI（Evaluate/Reset/Stop）、`LambdaCalculusCore`（`parse/expand/substitute/betaReduceOneStep/evaluateRealtime`）、スタイル。
* **差し込み**：本文では `インタプリタ（Code Slot A）` として参照。
* **元実装の仕様**：本章の UI/評価記述は v4 の公開版（スクロール修正込み）に一致。

```md
<!-- CODE SLOT A: place the interpreter HTML/JS here -->
<!-- file: appendix/interpreter.html -->
```

## Code Slot B — 前処理（表層糖衣→コア λ）

* **想定パス**：`appendix/preprocessor.md`（もしくは `.lam`）
* **責務**：`##/♭♭/…` → `Rel_apply k`、`M/CR` 記法 → `mkM/mkCR`、他トークンの正規化。

```md
<!-- CODE SLOT B: surface desugarer (preprocessor) -->
```

（章1の定義記法と**1:1対応**させること。）

## Code Slot C — 数学語彙の最小実装（章3で拡張）

* **想定パス**：`appendix/lib-core.lam`
* **内容**：`Bool/Pair/Nat/Z/Rat` と `Rat_norm`、`Fix`、`GcdNat` 等。

```md
<!-- CODE SLOT C: core library (Bool/Pair/Nat/Z/Rat/… minimal) -->
```

## Code Slot D — M/CR/QPoly（強い正規化つき）

* **想定パス**：`appendix/lib-mcr-qpoly.lam`
* **内容**：`Rel_apply/mkM/mkCR/cmpM/cmpCR`、`CR` 四則、`QPoly`、`CRp_norm_pair`（ord₀-drop／モニック化／content 約分／多項式 gcd）。

```md
<!-- CODE SLOT D: M/CR/QPoly with strong normalization -->
```

## Code Slot E — テストハーネス（Assert／バッチ）

* **想定パス**：`appendix/tests.lam`
* **内容**：`Assert`、Church リスト、直積生成、代表集合、網羅検査スイート。

```md
<!-- CODE SLOT E: testing harness (Assert / Church list / batch) -->
```

---

## 参考（本章の根拠）

* **最小 λインタプリタ（v4 公開版）**：UI 構成・正規順序・逐次βログ・循環検出・スクロール修正。
  本章の言語・評価・UI 記述はこれに準拠している。
* **第1章の記法と概念**：##／♭♭を**関係子**として扱う立場、$M=(k,a)$、$CR=(M,M)$ などの構成ポリシー。
  前処理規約はこれに整合させた。

---
