1-new-number-composition-Japanese
新しい数の構成方法
2024年07月17日 纏め作業開始
2025年08月11日 初回公開




木村 祐太 (1968-)




【前書き】

本稿は、研究中で執筆中の未完成の論文「数学の新しい基礎付け」の1章から、抜粋して先行公開している。下記は元となる論文の構成。

1章：数の構成の概念 (その抜粋が本稿)。
2章：定義や証明に必要な評価機の準備。
3章：数の構成と四則演算の定義と証明。

本論文の趣旨は、古典的な構成の実数や選択公理に起源する様々なパラドクスの解決と、無限桁の計算や無限回の処理に関する評価手続きのルール作りを行うことである。

また、本論文では、計算における構造的共通性やその証明の一部を行い、本論文以降の将来的には、無限級数の和や無限連分数の商が、有理数になるか無理数になるか等の構造的解明の第一歩になると考える。

本稿において、言葉は厳密な定義をせず、慣用的な使い方をしている。正式な定義や公理は、3章にて、λ計算インタプリタ上で実行するプログラミング言語として表現される。

本稿の、【自然数の構成】から【有理数の構成】は既存の方法による構成で、チャーチ数と同等である。その後の【有理極限と無理極限】から【新複素数の構成】は独自の構成である。

アラビア数字は全て10進数だが、本稿中の基本概念は基数に依存しない。

1章では、厳密性を保ちつつ要点を簡単にするために、関数は引数を持たない最小限の記号で表している。

本稿では、式を構成するオブジェクト記号と、式同士を区別するコンマやピリオドなどのメタ記号との混同を避けるために、全てのメタ記号を排除している。

複数の式を区別するために改行コードを使用しているが、例外的に使用しない場合はそれを明らかにし、式の区別にはセミコロンを使用している。




1章
数の構成の概念（抜粋）




【自然数の構成】

自然数 := 関数適用の回数

0 := f( )
1 := f(f( ))
2 := f(f(f( )))
3 := f(f(f(f( ))))
4 := f(f(f(f(f( )))))
…




【整数の構成】

整数 := (符号, 自然数)

…
2 := (0, 2) = (f( ), f(f(f( ))))
1 := (0, 1) = (f( ), f(f( )))
0 := (0, 0) = (f( ), f( ))
-1 := (1, 1) = (f(f( )), f(f( )))
-2 := (1, 2) = (f(f( )), f(f(f( ))))
…

ただし、(1, 0)は(0, 0)とする。
以降、定義時のアラビア数字はチャーチ数の整数型とする。



【有理数の構成】

有理数 := (整数, 整数)
= ((符号, 自然数), (符号, 自然数))

…
2/1 := (2, 1) = ((f( ), f(f(f( )))), (f( ), f(f( ))))
1/1 := (1, 1) = ((f( ), f(f( ))), (f( ), f(f( ))))
0/1 := (0, 1) = ((f( ), f( )), (f( ), f(f( ))))
-1/1 := (-1, 1) = ((f(f( )), f(f( ))), (f( ), f(f( ))))
-2/1 := (-2, 1) = ((f(f( )), f(f(f( )))), (f( ), f(f( ))))
…




【有理極限】

有理数aより大きくaに最も近い有理数を、関数としては表現できるものとし、それを「aの次の有理数」と呼び、下記の再帰で表した結果と定める。なお、再帰回数をどれだけ増やしても値は有理数であるものとする。

(1a+1)/1
(2a+1)/2
(3a+1)/3
(4a+1)/4
…

例えばaが5のとき、小数表記に変換すると、下記のように5に限りなく近づく数となる。

(1×5+1)/1 = 6
(2×5+1)/2 = 5.5
(3×5+1)/3 = 5.333…
…
(10×5+1)/10 = 5.1
…
(100×5+1)/100 = 5.01
…
(1000×5+1)/1000 = 5.001
…

この再帰処理を「有理極限」と呼ぶこととし、lim にちなんで qlim という名の関数とする。

aの次の有理数 := qlim(n, approaching-infinity)((n•a+b)/n)
ただし、nは1から順に大きくなる自然数で、bは1（実際は正の有理数なら何でもよい）。

bは全ての正の有理数において、計算の再帰回数を変えることで同じ値をとるので、本質な違いは無い。また、この概念は基数に依存しない。

lim は極限値を表すのに対し、qlim は極限値に到達しない有理数の値を返す再帰的関数である。

この概念は、無限をいきなり定義するのではなく、なるべく有限の道具だけを使って構成するという目的がある。関数の2番目の引数が「infinity」ではなく「approaching-infinity」としているのは、極限の概念との違いを表現するためである。

また、「次の数」という一意に定まる数があるかのような表現を使うが、実際に一意に定まるのは再帰関数そのものである。尚且つ、後述の新実数においてはその再帰関数さえも一意に定まらない。

そしてこの、aから、aの次の有理数への射を、

a##

と表す。

また、再帰的関数そのものをシンボル化して、シンボリック計算を行えるものとする。

次に、有理数aより小さくaに最も近い有理数を「aの前の有理数」と呼ぶこととし、下記の再帰で表す。

(1a-1)/1
(2a-1)/2
(3a-1)/3
(4a-1)/4
…

同じくaが5のとき、小数表記に変換すると、下記のように5に限りなく近づく数となる。

(1×5-1)/1 = 4
(2×5-1)/2 = 4.5
(3×5-1)/3 = 4.666…
…
(10×5-1)/10 = 4.9
…
(100×5-1)/100 = 4.99
…
(1000×5-1)/1000 = 4.999
…

同じく、aの前の有理数を下記のように表す。

aの前の有理数 := qlim(n, approaching-infinity)((n•a-b)/n)
ただし、nは1から順に大きくなる自然数で、bは 1（実際は正の有理数なら何でも良い）。

そしてこの、aから、aの前の有理数への射を、

a♭♭

と表記する。

## や ♭♭ は有理数同士の関係式で、音楽記号から借用している。

1## は無限小の概念と共通する面があり、1と1## との大きさの差は、絶対量としては定義できないものとする。つまり1に対して ## をいくつ増やすと2になるかは定まらない。ただし、1 < 1## であるものとする。また1と1## は不連続である。

有理極限の特徴として、bを正の数とした場合、

a < a## = qlim(n, approaching-infinity)((n•a+b)/n)
a > a♭♭ = qlim(n, approaching-infinity)((n•a-b)/n)
1 > 1♭♭ = 0.999…
1 > 1♭♭ = (1/2)+(1/4)+(1/8)+(1/16)+…
0 < 0## = (7/27)×(7/27)×(7/27)×…

などがある。従来では、有限の値に収束する無限級数の和の値として極限値が定義されているが、有理極限の数体系では極限値を和の値と定義せず、収束する先の値の1つ隣の有理数をその値と定義する。

上記の「(1/2)+…」の例では、無限和の値に「♭♭」の分の違いがある。さらには、後で述べる円周率を求めるための従来の単調増加における極限値との差は「♭♭」の半分であり、従来の数体系の曖昧な部分の1つを、有理極限では明確にしている。

実際の定義と運用時は、下記のように2つの式を一本化する。

aの隣の有理数 := qlim(n, approaching-infinity)((n•a+b)/n)
ただし、nは1から順に大きくなる自然数で、bが正の場合は次の有理数、負の場合は前の有理数、0の場合はaそのものを表す。

数の構成としては、aの隣の有理数である a## と a♭♭ は、順序対を使って下記のように表す。

aの次の有理数 := (関係式## , 有理数a)
aの前の有理数 := (関係式♭♭ , 有理数a)




【無理極限】

隣の有理数を表すために、元の有理数に対し2回適用していた関係式を、今度は1回だけ適用した数を無理極限と呼ぶこととし、それらは連続していると呼ぶこととする。

関係式を整数に割り当てる。

…
関係式#### := 4 = (f( ), f(f(f(f(f( ))))))
関係式### := 3 = (f( ), f(f(f(f( )))))
関係式## := 2 = (f( ), f(f(f( ))))
関係式# := 1 = (f( ), f(f( )))
関係式null := 0 = (f( ), f( ))
関係式♭ := -1 = (f(f( )), f(f( )))
関係式♭♭ := -2= (f(f( )), f(f(f( ))))
関係式♭♭♭ := -3 = (f(f( )), f(f(f(f( )))))
関係式♭♭♭♭ := -4 = (f(f( )), f(f(f(f(f( ))))))
…

aの大きい方に連続する無理極限 := (関係式# , 有理数a)
a := (関係式null , 有理数a)
aの小さい方に連続する無理極限 := (関係式♭ , 有理数a)

更に a# から a## 、a♭ から a♭♭ もそれぞれ連続していると呼ぶこととする。

つまり、

… < a♭♭♭♭ < a♭♭♭ < a♭♭ < a♭ < a < a# < a## < a### < a#### …

これらはそれぞれに大小関係があり、それぞれは連続している。

そして、有理極限と無理極限を合わせて連続順序数と呼ぶこととする。

連続順序数 := (関係式, 有理数)
= (整数, (整数, 整数))
= ((符号, 自然数), ((符号, 自然数), (符号, 自然数)))

…
2/1 := (0, 2/1) = ((f( ), f( )), ((f( ), f(f(f( )))), (f( ), f(f( )))))
1/1 := (0, 1/1) = ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
0/1 := (0, 0/1) = ((f( ), f( )), ((f( ), f( )), (f( ), f(f( )))))
-1/1 := (0, -1/1) = ((f( ), f( )), ((f(f( ) ), f(f( ))), (f( ), f(f( )))))
-2/1 := (0, -2/1) = ((f( ), f( )), ((f(f( )), f(f(f( )))), (f( ), f(f( )))))
…

連続順序数は morphism にちなんでM、あるいは𝕄とも表記できるものとする。

無理極限は、従来の無理数の要件を満たしていない。また、連続順序数は乗除算において閉じていないので、次に説明する新実数を構成するための中間的な数体系である。そして、連続順序数は自然数との1対1対応が可能である。

下記は、四則演算によって関係式の記号の追加や除去ができる例。

1♭ + 1# = 2
0## - 0### = 0♭
2## × (1/2) = 1#
0♭ / 0♭ = 1

下記は、追加や除去ができない例。

1# / 2 = 1# / 2
1# / 3 = 1# / 3
1 / 1# = 1 / 1#
1♭ / 1# = 1♭ / 1#




【新実数の構成（連続順序数の分数）】

この構成では、見やすさのために式の途中で改行コードを使用し、式の終わりはセミコロンを使用する。

新実数 := (連続順序数, 連続順序数)
= ((関係式, 有理数), (関係式, 有理数))
= ((整数, (整数, 整数)), (整数, (整数, 整数)))
= 
    (
    ((符号, 自然数), ((符号, 自然数), (符号, 自然数))), 
    ((符号, 自然数), ((符号, 自然数), (符号, 自然数)))
    );

…

2/1 := (2, 1) = 
    (
    ((f( ), f( )), ((f( ), f(f(f( )))), (f( ), f(f( ))))), 
    ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
    );

1/1 := (1, 1) = 
    (
    ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( ))))), 
    ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
    );

0/1 := (0, 1) = 
    (
    ((f( ), f( )), ((f( ), f( )), (f( ), f(f( ))))), 
    ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
    );

-1/1 := (-1, 1) = 
    (
    ((f( ), f( )), ((f(f( ) ), f(f( ))), (f( ), f(f( ))))), 
    ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
    );

-2/1 := (-2, 1) = 
    (
    ((f( ), f( )), ((f(f( )), f(f(f( )))), (f( ), f(f( ))))), 
    ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
    );

…

連続順序数は乗除算において閉じていなかったが、それを分数にすることで四則演算において閉じることができる。従来の実数との違いは、新実数においては自然数と1対1対応できることである。

新実数は Countable Real Number にちなんでCR、あるいはℂℝとも表記できるものとする。

新実数から(整数 / 整数)を除いた全ての数が従来の無理数に当たる。




【新複素数の構成】

この構成では、見やすさのために式の途中で改行コードを使用し、式の終わりはセミコロンを使用する。

新複素数 := ((新実数a, -新実数b), (新実数b, 新実数a))

新複素数の構成を、行列を使って表現する。1行目が(a -b)、2行目が(b a)の2行2列の行列を((a, -b), (b, a))と表記すると、新複素数は下記のように表現することができる。

a+bi = ((a, -b), (b, a))

a, bはそれぞれ新実数。

(1/1)+(2/1)i := 
((1/1, -(2/1)), (2/1, 1/1)) = 
((1/1, (-2/1)), (2/1, 1/1)) = 
(
    (
        (
        ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( ))))), 
        ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
        )
    ,
        (
        ((f( ), f( )), ((f(f( )), f(f(f( )))), (f( ), f(f( ))))), 
        ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
        )
    )
, 
    (
        (
        ((f( ), f( )), ((f( ), f(f(f( )))), (f( ), f(f( ))))), 
        ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
        )
    ,
        (
        ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( ))))), 
        ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))
        )
    )
);

新複素数はCC、あるいはℂℂとも表記できるものとする。

これらの数を評価機で評価する場合、あらかじめ全体の型を決め、言明し、その型で計算を行う。下記は、同じ1でも型による表現の違い。

自然数
1 = f(f( ))

整数
1 = (f( ), f(f( )))

有理数
1 = ((f( ), f(f( ))), (f( ), f(f( ))))

連続順序数
1 = ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( )))))

新実数
1 = (((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( ))))), ((f( ), f( )), ((f( ), f(f( ))), (f( ), f(f( ))))))




【数の包含関係】

自然数(関数適用の回数) 
⊂ 整数(符号付き自然数) 
⊂ 有理数(整数の分数) 
⊂ 連続順序数※(有理極限※と無理極限※) 
⊂ 新実数※(連続順序数の分数) 
⊂ 新複素数※(新実数の行列) ;

※印は独自の方法で構成した数。新四元数、新八元数などにも拡張可能。




【コラム：小数の表現力について】

従来の小数は無理数や、循環する数が0以外の循環小数を正確に表現できない。数学的に正式に定義されていない記号である「…」を用いることで、一部の有理数は何とか人に伝えることはできる。

0.333…
0.999…

そこで循環部分を明示的に指定することで、正確に循環小数を表現することもできる。

0._3 := 0.333…
0._6 := 0.666…

これは、アンダーバー以降の数列を無限に循環させるというルールである。それにより以下のような循環小数も正確に表現できる。

0._123 := 0.123123123…
0.5000_753 := 0.5000753753…
0._00 = 0._0 = 0

アンダーバー以降の数列が循環せずに無限個あれば無理数となる。この方法で全ての有理数が表現可能になる。




【交代級数】

1つの有限の値に収束する交代級数をこの数体系において観察すると、減少と増加をする2つの関数の2値が挟む数を最終的な級数の和とみなせる。

ライプニッツ級数の場合、

(π/4) = 1-(1/3)+(1/5)-(1/7)+(1/9)- …  

1×4 = 4
(1-(1/3))×4 = 2._6
(1-(1/3)+(1/5))×4 = 3.4_6
(1-(1/3)+(1/5)-(1/7))×4 = 2.8_952380
(1-(1/3)+(1/5)-(1/7)+(1/9))×4 = 3.3_396825
…

となり、

減少の値aは、
1×4 = 4
(1-(1/3)+(1/5))×4 = 3.4_6
(1-(1/3)+(1/5)-(1/7)+(1/9))×4 = 3.3_396825
(1-(1/3)+(1/5)-(1/7)+(1/9)-(1/11)+(1/13))×4 = 3.2_837384
…

増加の値bは、
(1-(1/3))×4 = 2._6
(1-(1/3)+(1/5)-(1/7))×4 = 2.8_952380
(1-(1/3)+(1/5)-(1/7)+(1/9)-(1/11))×4 = 2.9_760461
(1-(1/3)+(1/5)-(1/7)+(1/9)-(1/11)+(1/13)-(1/15))×4 = 3.0_170718
…

となり、連続順序数において、その2つの値を、

a♭♭ = b
または
b## = a

と表現できるものとし、その間の数a♭ またはb# を級数の和とする。すなわち、この級数の場合は、

a♭ = b# = π

となる。ただし、交代級数の和が1つの値に収束するかどうかの判別は、別の方法で確認する必要がある（3章）。

連続順序数においてaとa♭♭ との間にはa♭ しか存在しないが、新実数においては更にそこに無数の数を定義できる。

以上、これらの概念には従来の極限の概念を必要としない。




【交代級数の表現方法と実際の計算】

ここでは仮にLisp風に表現する。式の改行は見やすさのため。

・√2の従来の表現

(defun f () (+ 1 (/ 1.0 (+ 2 (f)))))

これはあくまで計算の概念を表したもので、実際に計算すると無限ループになる。実用的には、下記のようなn段の連分数で√2を近似しても良い。

(defun f (n)
  (labels ((g (k)
             (if (= k 0)
                 0
                 (/ 1.0 (+ 2 (g (- k 1))))))
           )
    (+ 1 (g n))))

・√2の連続順序数としての表現

(defun f () (+ 1 (/ 1.0 (+ 2 (g))))) ; …a
(defun g () (+ 1 (/ 1.0 (+ 2 (f))))) ; …b
; (a + b) / 2

; 以降、改行まではコメントとする。

最終的な級数の和としては、あくまでもaとbの間の値であって平均では無いが、近似値計算においては平均を取っても良い。
